// The MIT License - Copyright Â© 2010-2025 three.js authors
import{BufferAttribute as F,BufferGeometry as et,Float32BufferAttribute as $,InstancedBufferAttribute as J,InterleavedBuffer as rt,InterleavedBufferAttribute as nt,TriangleFanDrawMode as q,TriangleStripDrawMode as ot,TrianglesDrawMode as st,Vector3 as I}from"three";function ut(t,i,o=!0){if(!i||!i.isReady)throw new Error("BufferGeometryUtils: Initialized MikkTSpace library required.");if(!t.hasAttribute("position")||!t.hasAttribute("normal")||!t.hasAttribute("uv"))throw new Error('BufferGeometryUtils: Tangents require "position", "normal", and "uv" attributes.');function u(e){if(e.normalized||e.isInterleavedBufferAttribute){let s=new Float32Array(e.count*e.itemSize);for(let c=0,m=0;c<e.count;c++)s[m++]=e.getX(c),s[m++]=e.getY(c),e.itemSize>2&&(s[m++]=e.getZ(c));return s}return e.array instanceof Float32Array?e.array:new Float32Array(e.array)}let n=t.index?t.toNonIndexed():t,l=i.generateTangents(u(n.attributes.position),u(n.attributes.normal),u(n.attributes.uv));if(o)for(let e=3;e<l.length;e+=4)l[e]*=-1;return n.setAttribute("tangent",new F(l,4)),t!==n&&t.copy(n),t}function at(t,i=!1){let o=t[0].index!==null,u=new Set(Object.keys(t[0].attributes)),n=new Set(Object.keys(t[0].morphAttributes)),l={},e={},s=t[0].morphTargetsRelative,c=new et,m=0;for(let r=0;r<t.length;++r){let a=t[r],b=0;if(o!==(a.index!==null))return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+r+". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them."),null;for(let f in a.attributes){if(!u.has(f))return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+r+'. All geometries must have compatible attributes; make sure "'+f+'" attribute exists among all geometries, or in none of them.'),null;l[f]===void 0&&(l[f]=[]),l[f].push(a.attributes[f]),b++}if(b!==u.size)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+r+". Make sure all geometries have the same number of attributes."),null;if(s!==a.morphTargetsRelative)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+r+". .morphTargetsRelative must be consistent throughout all geometries."),null;for(let f in a.morphAttributes){if(!n.has(f))return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+r+".  .morphAttributes must be consistent throughout all geometries."),null;e[f]===void 0&&(e[f]=[]),e[f].push(a.morphAttributes[f])}if(i){let f;if(o)f=a.index.count;else if(a.attributes.position!==void 0)f=a.attributes.position.count;else return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+r+". The geometry must have either an index or a position attribute"),null;c.addGroup(m,f,r),m+=f}}if(o){let r=0,a=[];for(let b=0;b<t.length;++b){let f=t[b].index;for(let p=0;p<f.count;++p)a.push(f.getX(p)+r);r+=t[b].attributes.position.count}c.setIndex(a)}for(let r in l){let a=j(l[r]);if(!a)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the "+r+" attribute."),null;c.setAttribute(r,a)}for(let r in e){let a=e[r][0].length;if(a===0)break;c.morphAttributes=c.morphAttributes||{},c.morphAttributes[r]=[];for(let b=0;b<a;++b){let f=[];for(let d=0;d<e[r].length;++d)f.push(e[r][d][b]);let p=j(f);if(!p)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the "+r+" morphAttribute."),null;c.morphAttributes[r].push(p)}}return c}function j(t){let i,o,u,n=-1,l=0;for(let m=0;m<t.length;++m){let r=t[m];if(i===void 0&&(i=r.array.constructor),i!==r.array.constructor)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes."),null;if(o===void 0&&(o=r.itemSize),o!==r.itemSize)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes."),null;if(u===void 0&&(u=r.normalized),u!==r.normalized)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes."),null;if(n===-1&&(n=r.gpuType),n!==r.gpuType)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.gpuType must be consistent across matching attributes."),null;l+=r.count*o}let e=new i(l),s=new F(e,o,u),c=0;for(let m=0;m<t.length;++m){let r=t[m];if(r.isInterleavedBufferAttribute){let a=c/o;for(let b=0,f=r.count;b<f;b++)for(let p=0;p<o;p++){let d=r.getComponent(b,p);s.setComponent(b+a,p,d)}}else e.set(r.array,c);c+=r.count*o}return n!==void 0&&(s.gpuType=n),s}function lt(t){return t.isInstancedInterleavedBufferAttribute||t.isInterleavedBufferAttribute?L(t):t.isInstancedBufferAttribute?new J().copy(t):new F().copy(t)}function ct(t){let i,o=0,u=0;for(let m=0,r=t.length;m<r;++m){let a=t[m];if(i===void 0&&(i=a.array.constructor),i!==a.array.constructor)return console.error("AttributeBuffers of different types cannot be interleaved"),null;o+=a.array.length,u+=a.itemSize}let n=new rt(new i(o),u),l=0,e=[],s=["getX","getY","getZ","getW"],c=["setX","setY","setZ","setW"];for(let m=0,r=t.length;m<r;m++){let a=t[m],b=a.itemSize,f=a.count,p=new nt(n,b,l,a.normalized);e.push(p),l+=b;for(let d=0;d<f;d++)for(let z=0;z<b;z++)p[c[z]](d,a[s[z]](d))}return e}function L(t){let i=t.data.array.constructor,o=t.count,u=t.itemSize,n=t.normalized,l=new i(o*u),e;t.isInstancedInterleavedBufferAttribute?e=new J(l,u,n,t.meshPerAttribute):e=new F(l,u,n);for(let s=0;s<o;s++)e.setX(s,t.getX(s)),u>=2&&e.setY(s,t.getY(s)),u>=3&&e.setZ(s,t.getZ(s)),u>=4&&e.setW(s,t.getW(s));return e}function ft(t){let i=t.attributes,o=t.morphTargets,u=new Map;for(let n in i){let l=i[n];l.isInterleavedBufferAttribute&&(u.has(l)||u.set(l,L(l)),i[n]=u.get(l))}for(let n in o){let l=o[n];l.isInterleavedBufferAttribute&&(u.has(l)||u.set(l,L(l)),o[n]=u.get(l))}}function mt(t){let i=0;for(let u in t.attributes){let n=t.getAttribute(u);i+=n.count*n.itemSize*n.array.BYTES_PER_ELEMENT}let o=t.getIndex();return i+=o?o.count*o.itemSize*o.array.BYTES_PER_ELEMENT:0,i}function dt(t,i=1e-4){i=Math.max(i,Number.EPSILON);let o={},u=t.getIndex(),n=t.getAttribute("position"),l=u?u.count:n.count,e=0,s=Object.keys(t.attributes),c={},m={},r=[],a=["getX","getY","getZ","getW"],b=["setX","setY","setZ","setW"];for(let x=0,y=s.length;x<y;x++){let w=s[x],g=t.attributes[w];c[w]=new g.constructor(new g.array.constructor(g.count*g.itemSize),g.itemSize,g.normalized);let E=t.morphAttributes[w];E&&(m[w]||(m[w]=[]),E.forEach((A,h)=>{let T=new A.array.constructor(A.count*A.itemSize);m[w][h]=new A.constructor(T,A.itemSize,A.normalized)}))}let f=i*.5,p=Math.log10(1/i),d=Math.pow(10,p),z=f*d;for(let x=0;x<l;x++){let y=u?u.getX(x):x,w="";for(let g=0,E=s.length;g<E;g++){let A=s[g],h=t.getAttribute(A),T=h.itemSize;for(let S=0;S<T;S++)w+=`${~~(h[a[S]](y)*d+z)},`}if(w in o)r.push(o[w]);else{for(let g=0,E=s.length;g<E;g++){let A=s[g],h=t.getAttribute(A),T=t.morphAttributes[A],S=h.itemSize,X=c[A],M=m[A];for(let G=0;G<S;G++){let v=a[G],N=b[G];if(X[N](e,h[v](y)),T)for(let R=0,Y=T.length;R<Y;R++)M[R][N](e,T[R][v](y))}}o[w]=e,r.push(e),e++}}let B=t.clone();for(let x in t.attributes){let y=c[x];if(B.setAttribute(x,new y.constructor(y.array.slice(0,e*y.itemSize),y.itemSize,y.normalized)),x in m)for(let w=0;w<m[x].length;w++){let g=m[x][w];B.morphAttributes[x][w]=new g.constructor(g.array.slice(0,e*g.itemSize),g.itemSize,g.normalized)}}return B.setIndex(r),B}function ht(t,i){if(i===st)return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."),t;if(i===q||i===ot){let o=t.getIndex();if(o===null){let e=[],s=t.getAttribute("position");if(s!==void 0){for(let c=0;c<s.count;c++)e.push(c);t.setIndex(e),o=t.getIndex()}else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),t}let u=o.count-2,n=[];if(i===q)for(let e=1;e<=u;e++)n.push(o.getX(0)),n.push(o.getX(e)),n.push(o.getX(e+1));else for(let e=0;e<u;e++)e%2===0?(n.push(o.getX(e)),n.push(o.getX(e+1)),n.push(o.getX(e+2))):(n.push(o.getX(e+2)),n.push(o.getX(e+1)),n.push(o.getX(e)));n.length/3!==u&&console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");let l=t.clone();return l.setIndex(n),l.clearGroups(),l}else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:",i),t}function pt(t){let i=new I,o=new I,u=new I,n=new I,l=new I,e=new I,s=new I,c=new I,m=new I;function r(D,C,Z,Q,V,k,_,U){i.fromBufferAttribute(C,V),o.fromBufferAttribute(C,k),u.fromBufferAttribute(C,_);let W=D.morphTargetInfluences;if(Z&&W){s.set(0,0,0),c.set(0,0,0),m.set(0,0,0);for(let P=0,tt=Z.length;P<tt;P++){let H=W[P],O=Z[P];H!==0&&(n.fromBufferAttribute(O,V),l.fromBufferAttribute(O,k),e.fromBufferAttribute(O,_),Q?(s.addScaledVector(n,H),c.addScaledVector(l,H),m.addScaledVector(e,H)):(s.addScaledVector(n.sub(i),H),c.addScaledVector(l.sub(o),H),m.addScaledVector(e.sub(u),H)))}i.add(s),o.add(c),u.add(m)}D.isSkinnedMesh&&(D.applyBoneTransform(V,i),D.applyBoneTransform(k,o),D.applyBoneTransform(_,u)),U[V*3+0]=i.x,U[V*3+1]=i.y,U[V*3+2]=i.z,U[k*3+0]=o.x,U[k*3+1]=o.y,U[k*3+2]=o.z,U[_*3+0]=u.x,U[_*3+1]=u.y,U[_*3+2]=u.z}let a=t.geometry,b=t.material,f,p,d,z=a.index,B=a.attributes.position,x=a.morphAttributes.position,y=a.morphTargetsRelative,w=a.attributes.normal,g=a.morphAttributes.position,E=a.groups,A=a.drawRange,h,T,S,X,M,G,v,N=new Float32Array(B.count*B.itemSize),R=new Float32Array(w.count*w.itemSize);if(z!==null)if(Array.isArray(b))for(h=0,S=E.length;h<S;h++)for(M=E[h],G=Math.max(M.start,A.start),v=Math.min(M.start+M.count,A.start+A.count),T=G,X=v;T<X;T+=3)f=z.getX(T),p=z.getX(T+1),d=z.getX(T+2),r(t,B,x,y,f,p,d,N),r(t,w,g,y,f,p,d,R);else for(G=Math.max(0,A.start),v=Math.min(z.count,A.start+A.count),h=G,S=v;h<S;h+=3)f=z.getX(h),p=z.getX(h+1),d=z.getX(h+2),r(t,B,x,y,f,p,d,N),r(t,w,g,y,f,p,d,R);else if(Array.isArray(b))for(h=0,S=E.length;h<S;h++)for(M=E[h],G=Math.max(M.start,A.start),v=Math.min(M.start+M.count,A.start+A.count),T=G,X=v;T<X;T+=3)f=T,p=T+1,d=T+2,r(t,B,x,y,f,p,d,N),r(t,w,g,y,f,p,d,R);else for(G=Math.max(0,A.start),v=Math.min(B.count,A.start+A.count),h=G,S=v;h<S;h+=3)f=h,p=h+1,d=h+2,r(t,B,x,y,f,p,d,N),r(t,w,g,y,f,p,d,R);let Y=new $(N,3),K=new $(R,3);return{positionAttribute:B,normalAttribute:w,morphedPositionAttribute:Y,morphedNormalAttribute:K}}function gt(t){if(t.groups.length===0)return console.warn("THREE.BufferGeometryUtils.mergeGroups(): No groups are defined. Nothing to merge."),t;let i=t.groups;if(i=i.sort((e,s)=>e.materialIndex!==s.materialIndex?e.materialIndex-s.materialIndex:e.start-s.start),t.getIndex()===null){let e=t.getAttribute("position"),s=[];for(let c=0;c<e.count;c+=3)s.push(c,c+1,c+2);t.setIndex(s)}let o=t.getIndex(),u=[];for(let e=0;e<i.length;e++){let s=i[e],c=s.start,m=c+s.count;for(let r=c;r<m;r++)u.push(o.getX(r))}t.dispose(),t.setIndex(u);let n=0;for(let e=0;e<i.length;e++){let s=i[e];s.start=n,n+=s.count}let l=i[0];t.groups=[l];for(let e=1;e<i.length;e++){let s=i[e];l.materialIndex===s.materialIndex?l.count+=s.count:(l=s,t.groups.push(l))}return t}function bt(t,i=Math.PI/3){let o=Math.cos(i),u=(1+1e-10)*100,n=[new I,new I,new I],l=new I,e=new I,s=new I,c=new I;function m(d){let z=~~(d.x*u),B=~~(d.y*u),x=~~(d.z*u);return`${z},${B},${x}`}let r=t.index?t.toNonIndexed():t,a=r.attributes.position,b={};for(let d=0,z=a.count/3;d<z;d++){let B=3*d,x=n[0].fromBufferAttribute(a,B+0),y=n[1].fromBufferAttribute(a,B+1),w=n[2].fromBufferAttribute(a,B+2);l.subVectors(w,y),e.subVectors(x,y);let g=new I().crossVectors(l,e).normalize();for(let E=0;E<3;E++){let A=n[E],h=m(A);h in b||(b[h]=[]),b[h].push(g)}}let f=new Float32Array(a.count*3),p=new F(f,3,!1);for(let d=0,z=a.count/3;d<z;d++){let B=3*d,x=n[0].fromBufferAttribute(a,B+0),y=n[1].fromBufferAttribute(a,B+1),w=n[2].fromBufferAttribute(a,B+2);l.subVectors(w,y),e.subVectors(x,y),s.crossVectors(l,e).normalize();for(let g=0;g<3;g++){let E=n[g],A=m(E),h=b[A];c.set(0,0,0);for(let T=0,S=h.length;T<S;T++){let X=h[T];s.dot(X)>o&&c.add(X)}c.normalize(),p.setXYZ(B+g,c.x,c.y,c.z)}}return r.setAttribute("normal",p),r}export{ut as computeMikkTSpaceTangents,pt as computeMorphedAttributes,lt as deepCloneAttribute,L as deinterleaveAttribute,ft as deinterleaveGeometry,mt as estimateBytesUsed,ct as interleaveAttributes,j as mergeAttributes,at as mergeGeometries,gt as mergeGroups,dt as mergeVertices,bt as toCreasedNormals,ht as toTrianglesDrawMode};
